From bb25f3f11b313d6cdf5a5186f208e672864fc6b9 Mon Sep 17 00:00:00 2001
From: Matteo Geromin <geromin.matteo@gmail.com>
Date: Wed, 19 Oct 2016 00:08:55 +0200
Subject: [PATCH 5/7] fb: da8xx-fb: add splashscreen continuity from u-boot to
 kernel

---
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   2 +-
 drivers/video/fbdev/da8xx-fb.c             | 110 ++++++++++++++++++++++++++---
 2 files changed, 100 insertions(+), 12 deletions(-)
 mode change 100644 => 100755 arch/arm/mach-omap2/omap_hwmod_33xx_data.c
 mode change 100644 => 100755 drivers/video/fbdev/da8xx-fb.c

diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
old mode 100644
new mode 100755
index 24ce8b5..940ff5b
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -228,7 +228,7 @@ static struct omap_hwmod am33xx_lcdc_hwmod = {
 	.name		= "lcdc",
 	.class		= &am33xx_lcdc_hwmod_class,
 	.clkdm_name	= "lcdc_clkdm",
-	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY,
+	.flags		= HWMOD_INIT_NO_IDLE | HWMOD_NO_IDLEST | HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY,
 	.main_clk	= "lcd_gclk",
 	.prcm		= {
 		.omap4	= {
diff --git a/drivers/video/fbdev/da8xx-fb.c b/drivers/video/fbdev/da8xx-fb.c
old mode 100644
new mode 100755
index e6568a5..f3d1bd0
--- a/drivers/video/fbdev/da8xx-fb.c
+++ b/drivers/video/fbdev/da8xx-fb.c
@@ -37,6 +37,8 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/lcm.h>
+#include <linux/of.h>
+#include <video/of_display_timing.h>
 #include <video/da8xx-fb.h>
 #include <asm/div64.h>
 
@@ -140,6 +142,7 @@ static unsigned int lcd_revision;
 static irq_handler_t lcdc_irq_handler;
 static wait_queue_head_t frame_done_wq;
 static int frame_done_flag;
+static bool u_boot_config = false;
 
 static unsigned int lcdc_read(unsigned int addr)
 {
@@ -1265,7 +1268,7 @@ static int da8xxfb_set_par(struct fb_info *info)
 	int ret;
 	bool raster = da8xx_fb_is_raster_enabled();
 
-	if (raster)
+	if (!u_boot_config && raster)
 		lcd_disable_raster(DA8XX_FRAME_WAIT);
 
 	fb_var_to_videomode(&par->mode, &info->var);
@@ -1293,7 +1296,7 @@ static int da8xxfb_set_par(struct fb_info *info)
 	lcdc_write(par->dma_start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);
 	lcdc_write(par->dma_end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);
 
-	if (raster)
+	if (!u_boot_config && raster)
 		lcd_enable_raster();
 
 	return 0;
@@ -1312,12 +1315,54 @@ static struct fb_ops da8xx_fb_ops = {
 	.fb_blank = cfb_blank,
 };
 
+static struct lcd_ctrl_config *da8xx_fb_create_cfg(struct platform_device *dev)
+{
+	struct lcd_ctrl_config *cfg;
+
+	cfg = devm_kzalloc(&dev->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+	if (!cfg)
+		return NULL;
+
+	/* default values */
+
+	if (lcd_revision == LCD_VERSION_1)
+		cfg->bpp = 16;
+	else
+		cfg->bpp = 32;
+
+	/*
+	 * For panels so far used with this LCDC, below statement is sufficient.
+	 * For new panels, if required, struct lcd_ctrl_cfg fields to be updated
+	 * with additional/modified values. Those values would have to be then
+	 * obtained from dt(requiring new dt bindings).
+	 */
+
+	cfg->panel_shade = COLOR_ACTIVE;
+
+	return cfg;
+}
+
 static struct fb_videomode *da8xx_fb_get_videomode(struct platform_device *dev)
 {
 	struct da8xx_lcdc_platform_data *fb_pdata = dev_get_platdata(&dev->dev);
 	struct fb_videomode *lcdc_info;
+	struct device_node *np = dev->dev.of_node;
 	int i;
 
+	if (np) {
+		lcdc_info = devm_kzalloc(&dev->dev,
+					 sizeof(struct fb_videomode),
+					 GFP_KERNEL);
+		if (!lcdc_info)
+			return NULL;
+
+		if (of_get_fb_videomode(np, lcdc_info, OF_USE_NATIVE_MODE)) {
+			dev_err(&dev->dev, "timings not available in DT\n");
+			return NULL;
+		}
+		return lcdc_info;
+	}
+
 	for (i = 0, lcdc_info = known_lcd_panels;
 		i < ARRAY_SIZE(known_lcd_panels); i++, lcdc_info++) {
 		if (strcmp(fb_pdata->type, lcdc_info->name) == 0)
@@ -1343,14 +1388,23 @@ static int fb_probe(struct platform_device *device)
 	struct fb_info *da8xx_fb_info;
 	struct da8xx_fb_par *par;
 	struct clk *tmp_lcdc_clk;
+	u32 videomemorysize;
+	u32 videomem_offset;
 	int ret;
 	unsigned long ulcm;
 
-	if (fb_pdata == NULL) {
+	if (fb_pdata == NULL && !device->dev.of_node) {
 		dev_err(&device->dev, "Can not get platform data\n");
 		return -ENOENT;
 	}
 
+	if (of_find_property(device->dev.of_node, "u-boot-config", NULL))
+	{
+		u_boot_config = true;
+		of_property_read_u32(device->dev.of_node, "fb-baseaddr", &videomem_offset);
+		of_property_read_u32(device->dev.of_node, "fb-size-MB", &videomemorysize);
+	}
+
 	lcdc_info = da8xx_fb_get_videomode(device);
 	if (lcdc_info == NULL)
 		return -ENODEV;
@@ -1394,7 +1448,10 @@ static int fb_probe(struct platform_device *device)
 		break;
 	}
 
-	lcd_cfg = (struct lcd_ctrl_config *)fb_pdata->controller_data;
+	if (device->dev.of_node)
+		lcd_cfg = da8xx_fb_create_cfg(device);
+	else
+		lcd_cfg = fb_pdata->controller_data;
 
 	if (!lcd_cfg) {
 		ret = -EINVAL;
@@ -1413,7 +1470,7 @@ static int fb_probe(struct platform_device *device)
 	par->dev = &device->dev;
 	par->lcdc_clk = tmp_lcdc_clk;
 	par->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);
-	if (fb_pdata->panel_power_ctrl) {
+	if (fb_pdata && fb_pdata->panel_power_ctrl) {
 		par->panel_power_ctrl = fb_pdata->panel_power_ctrl;
 		par->panel_power_ctrl(1);
 	}
@@ -1421,7 +1478,8 @@ static int fb_probe(struct platform_device *device)
 	fb_videomode_to_var(&da8xx_fb_var, lcdc_info);
 	par->cfg = *lcd_cfg;
 
-	da8xx_fb_lcd_reset();
+	if (!u_boot_config)
+		da8xx_fb_lcd_reset();
 
 	/* allocate frame buffer */
 	par->vram_size = lcdc_info->xres * lcdc_info->yres * lcd_cfg->bpp;
@@ -1429,10 +1487,16 @@ static int fb_probe(struct platform_device *device)
 	par->vram_size = roundup(par->vram_size/8, ulcm);
 	par->vram_size = par->vram_size * LCD_NUM_BUFFERS;
 
-	par->vram_virt = dma_alloc_coherent(NULL,
+	if(u_boot_config) {
+		par->vram_virt = ioremap(videomem_offset,(videomemorysize*1024*1024));
+		par->vram_phys = videomem_offset;
+	} else {
+		par->vram_virt = dma_alloc_coherent(NULL,
 					    par->vram_size,
 					    (resource_size_t *) &par->vram_phys,
 					    GFP_KERNEL | GFP_DMA);
+	}
+
 	if (!par->vram_virt) {
 		dev_err(&device->dev,
 			"GLCD: kmalloc for frame buffer failed\n");
@@ -1463,10 +1527,12 @@ static int fb_probe(struct platform_device *device)
 	}
 	memset(par->v_palette_base, 0, PALETTE_SIZE);
 
-	par->irq = platform_get_irq(device, 0);
-	if (par->irq < 0) {
-		ret = -ENOENT;
-		goto err_release_pl_mem;
+	if(!u_boot_config) {
+		par->irq = platform_get_irq(device, 0);
+		if (par->irq < 0) {
+			ret = -ENOENT;
+			goto err_release_pl_mem;
+		}
 	}
 
 	da8xx_fb_var.grayscale =
@@ -1515,6 +1581,14 @@ static int fb_probe(struct platform_device *device)
 	}
 #endif
 
+	if(u_boot_config) {
+		par->irq = platform_get_irq(device, 0);
+		if (par->irq < 0) {
+			ret = -ENOENT;
+			goto err_release_pl_mem;
+		}
+	}
+
 	if (lcd_revision == LCD_VERSION_1)
 		lcdc_irq_handler = lcdc_irq_handler_rev01;
 	else {
@@ -1661,6 +1735,19 @@ static int fb_resume(struct platform_device *dev)
 #define fb_resume NULL
 #endif
 
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id da8xx_fb_of_match[] = {
+	/*
+	 * this driver supports version 1 and version 2 of the
+	 * Texas Instruments lcd controller (lcdc) hardware block
+	 */
+	{.compatible = "ti,da8xx-tilcdc", },
+	{.compatible = "ti,am33xx-tilcdc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, da8xx_fb_of_match);
+#endif
+
 static struct platform_driver da8xx_fb_driver = {
 	.probe = fb_probe,
 	.remove = fb_remove,
@@ -1668,6 +1755,7 @@ static struct platform_driver da8xx_fb_driver = {
 	.resume = fb_resume,
 	.driver = {
 		   .name = DRIVER_NAME,
+		   .of_match_table = of_match_ptr(da8xx_fb_of_match),
 		   .owner = THIS_MODULE,
 		   },
 };
-- 
1.9.1

